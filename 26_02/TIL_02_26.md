# TIL 02.26
<h3> Unreal Blueprint</h3>
<h4>레벨 디자인이란?</h4> 
플레이어가 탐험하고, 상호작용하는 공간을 설계하는 일입니다(동선, 도전, 몰입감)

- 캐릭터 매시(skeleton)
- camera Component <- Spring Arm 컴포넌트 생성 후 부착

* Enhanced Input System: Unreal의 입력 시스템/ 키보드, 마우스, 게임패드 등을 더 유연하게 지원하고, 복잡한 컨트롤 매핑도 쉽게 설정할 수 있도록 도와주는 시스템
* Input Action: 입력 값 지정
* Input Mapping Context: 입력 액션에서 입력 이벤트를 정의하고, 맵핑 컨텍스트에서 키를 액션에 맵핑해주는 개념
    - Negate: 부정(역방향)
    - Swizzle Input Axis Values:  Y축 방향

BP_IMC 설정
![alt text](Image/BP_IMC_26_02_26.png)

* Get Control Rotation(Target is Pawn)을 사용하여 Pawn의 방향을 기준으로 한 값을 받을 수 있음
* Add Movement Input(Target is Pawn)으로 이동

* Yaw: 좌우
* Pitch: 상하


* 캐릭터 전체의 Controller Rotation Pitch/Yaw 해제 -> Character Movement의 OrientRotation to Movement 체크 -> SpringArm의 Use Pawn Control Rotation 체크
> 플레이어 보는 방향 기준 움직임

---
<h2>알고리즘</h2>
<h3>12892 생일 선물</h3>
- 투 포인터 사용<br>
- 범위 내 최댓값 구하기<br>
- 정수 타입 int < overflow발생

---
<h2>C++ 코딩 테스트 완전 정복</h2>
<h3>STL 사용하기</h3>

* STL(Standard Template Library): C++ 표준 라이브러리의 일부로, 자주 사용되는 컨테이너와 알고리즘을 템플릿 기반으로 제공하는 라이브러리
1. 다양한 타입에 대해 제네릭 프로그래밍이 가능하며, 코드의 재사용성이 높습니다
2. 일관된 인터페이스를 통해 다양한 컨테이너와 알고리즘을 유사한 방식으로 사용할 수 있습니다.
    - 컨테이너: 데이터를 저장하고, 관리하는 객체
    - 알고리즘: 컨테이너에 저장된 데이터를 처리하는 다양한 함수를 제공
    - 반복자: 컨테이너의 요소들을 순회하고, 접근하는 방법을 제공합니다.

* 반복자
    - 순방향 반복자: 앞에서부터 차레로 순회하며, 각 원소에 접근할 수 있는 반복자
    1. begin(): 처음 위치, end(): 마지막 위치
    2. 반복자가 가리키는 곳을 읽거나 수정할 수 있음
    3. ++연산자를 지원함

    - 역방향 반복자: 뒤에서부터 순회하며 각 원소에 접근할 수 있는 반복자
    1. rbegin(): 마지막 요소, rend() 첫 번째 요소 바로 앞 위치를 가리킴
    2. 반복자가 가리키고 잇는 곳을 읽거나 수정할 수 있습니다.
    3. ++, -- 연산자를 지원함

* Vector: 배열과 유사한 컨테이너, 크기를 동적으로 조절할 수 있음
    - 선언 및 초기화<br>
    vector<dataType> name;
    1. 크기 및 초기값을 지정하지 않았을때 vector의 크기는 0입니다.
    2. vector<int> vec = {1,2,3}과 같이 선언과 동시에 초기값을 직접 지정할 수 있습니다.
    3. vector<int> v2 = v1으로 기존 벡터의 값을 복사할 수 있습니다.
    4. vector<int> v(5,10) 10으로 초기화된 크기가 5인 백터 생성

    - vector의 원소 변경<br>
    [ ]연산자를 사용해 특정 위치의 원소에 접근 가능
    - vector의 삽입과 삭제<br>
        - 원소 삽입 -> push_back()
        - 중간 삽입 -> insert(위치, 값)
        - 모든 원소 삽입 -> clear()

* Set: 중복되지 않는 원소들을 정렬된 상태로 저장하는 컨테이너
    - 선언 및 초기화<br>
    set<DataType> name
    1. set<int> s로 빈 set 선언
    2. set<int> s = { 3,1,4}로 초기화 가능
    3. set<int> s2 = s1로 기존 Set 복사 가능

    - set의 삽입과 삭제<br>
    1. 삽입 -> insert() >> 원소를 삽입할 때마다 정렬된 상태를 유지합니다.
    2. 삭제 -> erase() >> 원소를 삭제할 때마다 정렬된 상태를 유지합니다.
    3. 모든 원소 삭제 -> clear()

    - set은 중복된 원소를 허용하지 않음, 필요하다면 multiset
    - 정렬이 필요하지 않고, 빠른 탐색이 중요할 경우 해시 기반의 unordered_set
    - set은 index을 지원하지 않음

* Map: 키와 값을 쌍으로 갖는 연관 컨테이너, 중복키를 허용하지 않으며, 오름차순으로 정렬됨<br>
map<keyType, valueType> m
1. {{key1, value1}, {key2, value2}...}으로 초기화 가능
2. map<string, int> m1 = m2로 기존 map 복사 가능

    - 맵의 원소 변경
    1. [ ] 연산자를 활용해서 변경<br>
    m["Alice"] = 31 -> "Alice"키와 연결된 값을 31로 변경, 만약 해당 키가 없다면 새로운 키-값을 만듭니다
    2. at(키) = 변경할 값 -> 키에 연결된 값을  입력된 값으로 바꿉니다.(존재하지 않는 키는 at() 사용 불가)

    - map의 삽입과 삭제
    1. 삽입 -> insert()
    2. 삭제 -> erase()
    3. 모든 원소 삭제 -> clear()

    - 키만 필요하고 값이 필요하지 않은 경우 set 추천
    * 키는 명확해야 하며, 부동 소수점을 키로 사용하는 것은 피해야함

* sort(): 오름 차순으로 범위에 있는 원소를 정렬<br>
sort(first, last)
    - comp(a,b): 사용자 정의 비교 함수 -> true: a가 b보다 먼저옴, false: a가 b보다 먼저 오지 않음

* find(): 범위 내 특정 값과 일치하는 첫 번째 원소를 탐색함<br>
find(fitst, last, value)

* count(): 범위 내 특정 값이 몇번 등장하는지를 반환<br>
count(first, last, value)

* unique(): 범위 내 연속된 중복 요소를 제거합니다.<br>
실제로 원소가 삭제되는 것은 아니기에 보통 erase()와 같이 사용함<br>
erase(first, last)
    * erase(unique(first, last), last)

---
<h2>C/C++</h2>

* 배열: 사용할 메모리 크기를 고정해서 선언, 선언 후에는 크기 변경 불가(정적)
    - 배열의 index는 항상 0부터 시작
 
* 2차원 배열: 1차원 배열을 쌓아 올린 형태

* 함수: 코드 뭉치, 반복되는 코드 뭉치가 있다면 그 코드 뭉치를 함수로 만들어 재사용성을 높일 수 있다
``` C++
    반환 자료형 함수명(매개변수 자료형 매개변수명){
        코드 ...
        return 반환값;
    }
```